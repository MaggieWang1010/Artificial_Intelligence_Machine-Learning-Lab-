# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OOa1mffO-uForfjvhEQd4yLfXkLQ_ZAP
"""

#-----------Array Object and its Attributes------------
import numpy as np
list1=[1.0,2.0,3.0,4.0,5.0]
npy_array=np.array(list1, dtype=np.float64)
#convert list to array(or something like matrix)
npy_array.ndim # get dimension of array
a=np.array([[1,2,3],[4,5,6],[7,8,9]], dtype=np.float64)
np.array #like creating matrix
a.ndim#2
a.shape#(3,3)
a.size # total elem in an array
a.itemsize # each elem's size(in bytes)
a.dtype.name # get elem data type name
type(a) # <class 'ndarray'> ndim array
np.indices((3,5)) # get index matrix for each elme in 3x5 matrix
#
#--------------Special Mathematical Arrays--------------
np.eye(4) # get eye matrix 
np.identity(3) # like eye function
z = np.zeros((3,4), dtype=np.int)
z = np.ones((3,4), dtype=np.float64)
z=np.random.random(())
z=np.random.uniform(-3, 5, (5,6))
# get 5x6 matrix with random # from -3 to 5 for each elem
z
#
#----------------Arrays and Functions for Plotting----------------
x=np.linspace(-10,10,201)
x1=np.arange(-10.0, 10.0, 0.1)
sine=np.sin(x)
import matplotlib.pyplot as plt
plt.plot(x,sine)
plt.show()
quad1=x**2 + 2.0*x +5.0
plt.plot(x,quad1)
plt.show()
def norm_func(x,mean,var):
 return 1.0/(var*(2*np.pi)**0.5) * np.exp(-1/2*((x-mean)/var)**2)
x=np.arange(-5,5.01,0.05)
pdf1=norm_func(x,0,0.2**0.5)
pdf2=norm_func(x,0,1.0**0.5)
pdf3=norm_func(x,0,5.0**0.5)
pdf4=norm_func(x,-2.0,0.5**0.5)
plt.plot(x,pdf1,color='blue', label="mean={} var^2={}".format(0,0.2))
plt.plot(x,pdf2,color='red', label="mean={} var^2={}".format(0,1.0))
plt.plot(x,pdf3,color='yellow', label="mean={} var^2={}".format(0,5.0))
plt.plot(x,pdf4,color='green', label="mean={} var^2={}".format(-2.0,0.5))
plt.legend()
plt.show()
#
#-----------------Meshgrid in detail for gridded data-------------------
x=np.linspace(-4,4,9)
y=np.linspace(-5,5,11)
xx,yy=np.meshgrid(x,y) # create x, y grid matrix
xx.shape
yy.shape
ellipse = xx**2 + 4*yy**4 #
plt.contourf(xx,yy,ellipse, cmap='jet') # generate contour line
# 'jet': Red for big value; Blue for small 
plt.colorbar() # create color bar at the side
plt.show()
random_data=np.random.random((11,9))
plt.contourf(xx,yy,random_data, cmap='jet') # generate contour line
  # jet - color seq:blue-cyan-yello-red
plt.colorbar() # create color bar at the sideplt.show
plt.show()
xx1,yy1=np.meshgrid(x,y, indexing='ij')
# xx1 is transpose xx; yy1 is transpose yy
np.all(xx == xx1.T) # xx1.T - transpose matrix #--True
np.all([1,2] == [1,3])#--False
#
#------------------Vector and Matrix Operations------------
A=np.ones((5,3))
B=5*np.ones((5,3))
C=np.random.randint(-5,5,(3,5))
np.multiply(A,B) # elem times elem, not matrix multiplication
A/B
A+=B
A**=B
np.sqrt(A)
np.power(A,2)
np.exp(A)
np.dot(A,B.T)
a= np.array([[-2, 1, 1],[0,2,0],[-4,1,3]])
print(a.shape)
b=np.array([4, 5, 6])
print(b.T.shape)
c=np.dot(a,b.T)
c.shape
np.linalg.det(a) # determinant
np.linalg.inv(a) # inverse matrix
eigval, eigvec = np.linalg.eig(a) # a must be square
# return eigen values and eigen vectors
# each col in eigvec is each eigval's corresponding vector
eigval
eigvec